---
layout: post
title:  "iterator가 존재하는 이유에 대한 고찰"
date:   2021-07-03
categories: C++
---
      
기본적으로 C++ STL 알고리즘은 "데이터 컨테이너" 라이브러리와 "알고리즘" 라이브러리와 "이터레이터" 라이브러리 부분으로 나뉜다.            
여기서 "알고리즘" 라이브러리는 대개 "데이터 컨테이너" 라이브러리의 컨테이너 타입을 가지고 작동한다.      
여기서 부터는 코드를 보며 설명하겠다.          
```c++
struct MyVector
{
    int* mData;
    ~~
    ~~
}

struct MyLinkedList
{
    LinkedListNode* mStartNode;
}

template<typename T>
void SortContainer(T& container){}
```

자 기본적으로 Sort를 하려고 하면 해당 컨테이너에 item에 모두 접근해야한다.        
그럼 Vector는 어떻게 다음 item에 접근할까? 현재 item의 포인터에 1을 더하면 된다.        
그럼 LinkedList는 어떻게 다음 item에 접근할까? 현재 node가 가지고 있는 다음 node의 주소를 참조하면된다.     

**여기서 문제가 발생한다. 그럼 SortContainer 함수는 두 Vector와 LinkedList에서 다음 item으로 가는 방법을 모두 알고 있어야 하나?**            
**그리고 그 컨테이너 타입마다 일일이 다음 item으로 가는 구현 코드를 따로 만들어야 하나??**                                         

그래서 iterator가 쓰이는 것이다!!!!      

```c++
struct MyVector
{
    int* mData;
    ~~
    ~~
}

struct MyLinkedList
{
    LinkedListNode* mStartNode;
}

class Iterator 
{ 
    public:
    virtual void NextItem() = 0;
}

class MyVectorIterator : public Iterator 
{ 
    public:
    virtual void NextItem() final { ~~ }
} 
class MyLinkedListIterator : public Iterator 
{
    public:
    virtual void NextItem() final { ~~ }
} 

template<typename T>
void SortContainer(Iterator iterator)
{
    iterator.NextItem() 
    ~~
}
```

