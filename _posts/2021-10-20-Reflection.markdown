---
layout: post
title:  "언리얼 엔진의 리플랙션와 같은 시스템 구현하기 ( 작성 중 )"
date:   2021-10-20
categories: ComputerScience
---

흔히 언리얼 엔진을 사용해보면 아주 편리함 시스템이 StaticClass, IsA와 같이 컴파일 타임이 아닌 런타임에 클래스간의 상속 관계를 판단하는 등의 여러 리플렉션 시스템이다.         
언리얼 엔진은 이를 위해 게임 내 모든 헤더파일을 분석, 파싱하여 "XXX.generated.h"라는 헤더 파일에 해당 타입에 대한 정보를 담는다.          
아마 이 글을 읽는 당신의 언리얼 헤더 파일들이 모두 "XXX.generated.h" 파일을 #include 하고 있는 것을 알 수 있을 것이다.        

이를 위해서는 타입에 대한 정보 ( 타입명, 타입의 유니크한 ID, 타입의 부모 클래스들의 정보, 멤버 함수 종류, 멤버 변수 종류, 멤버 함수의 주소 등등 )가 필요한데 C++에서는 이러한 정보를 제공해주지 않기 때문에 흔히 **리플랙션**이라고 부르는 시스템을 만들어서 이러한 타입 정보를 런타임에 접근할 수 있게 만든다.        
필자 또한 게임 엔진을 만들면서 런타임에 타입 정보를 가져와야할 필요가 있었다.      

또한 dynamic_cast가 너무 느리기 때문에 이를 대체할 것이 필요했다. dynamic_cast가 느린 이유는 dynamic_cast는 부모, 자식뿐만아니라 형제들까지 온갖 상속 관계를 뒤져서 캐스팅을 한다.       
그러나 C++을 사용해보면 알겠지만 형제 클래스로 캐스팅할 확률은 거의 드물다. 부모, 자녀간의 캐스팅이면 충분하다. 그래서 필자는 부모, 자녀간의 안전한 ( 상속 관계 검사를 수행하는 ) 캐스팅 직접 만들기로 결정하였다.         


언리얼엔진은 소스파일을 파싱해서 클래스들의 모든 정보를 분석한 후 빌드 단계에서 컴파일해서 빌드 파일에 담는다.         
유비소프트 몬테리올에서도 언리얼엔진과 같이 소스파일을 자동으로 파싱해서 해당 데이터를 dll 파일에 저장해둔 후 런타임에 해당 dll 파일을 로드해서 타입 정보를 읽어온다. ( [clReflect](https://github.com/Celtoys/clReflect) )         

사실 나도 이 오픈소스를 그냥 사용하면된다.           

하지만 또 이상한 병이 도져 직접 만들기로 결정하였다.     
그냥 만들어보고 싶었다.      


언리얼엔진이나 clReflect와 같이 소스파일을 분석해서 자동으로 타입 정보를  완전히 자동화되지는 않았지만 클래스 정의 맨 앞에 어떤 **매크로를 추가하고 타입명을 넘기면** 언리얼과 같은 리플렉션, 타입 정보를 런타임에 확인할 수 있게 구현하였다.          
언리얼엔진, clReflect에서 컴퓨터가 해주는 일을 내가 만든 시스템에서는 프로그래머가 직접 해야하기 때문에 약간은 귀찮아보이지만, **각 클래스마다 딱 2줄의 코드만을 추가**하면 되기 때문에 이 정도면 납득 가능하다고 생각한다.          

아래는 리플랙션 시스템을 지원하기 위해 클래스에 추가해야할 매크로 코드이다.     
딱 2줄이다!!           
클래스들간의 상속관계 같은 경우 각 클래스마다 매크로로 해당 클래스의 부모 클래스 타입명을 넘겨주어야한다.      

```
    class DOOM_API MeshCollider : public Collider3DComponent
    {
        DOBJECT_CLASS_BODY(MeshCollider)
        DOBJECT_CLASS_BASE_CHAIN(Collider3DComponent)
    }
```

이 두줄의 코드를 통해 엔진내 거의 모든 클래스들의 타입 정보를 DClass라는 클래스로 객체화하였다. 클래스명, 클래스들간의 상속 관계 등의 여러 클래스 타입 정보를 런타임에 얻을 수 있다.         

언리얼 엔진과 같이 부모 클래스 타입을 임의로 적어줄 필요없이 "Base" type alias로 부모 클래스의 멤버에 접근할 수 있다.         

다만 클래스 내부의 변수나 함수들의 정보를 런타임에 가져오지는 못한다.          
구현하려면 할 수는 있지만 현재 필자의 프로젝트에서는 아직까지 필요하지 않아 차후에 필요시 추가할 예정이다.        

상속 관계는 전역변수로 프로그램 시작 단계에서 부모 클래스를 타고 올라가면서 각 부모 클래스의 유니크한 타입 ID를 저장한다.          
그럼 해당 컨테이너는 이러한 데이터 형태를 가질 것이다.       
```
( 부모 클래스 ID ) ( 조부모 클래스 ID ) ( 증조부모 클래스 ID ) ( 고조부모 클래스 ID )
```

그럼 어떤 오브젝트가 포인터로 넘어왔을 때 그 오브젝트가 어떤 다른 클래스의 자식인지를 어떻게 알 수 있을까?      
방법은 간단하다.      

```
부모 리스트 컨테이너 [ 비교하려는 오브젝트의 부모들의 개수 ( 높이 ) - 1 - 비교하려는 클래스의 부모들의 개수 ] == 비교하려는 클래스의 타입 ID
```

이를 통해 모든 부모 리스트를 탐색하지 않고 O(1)만에 비교하려는 클래스가 현재 오브젝트의 부모인지 아닌지를 확인할 수 있다.       


결과적으로 **모든 목표를 달성**했다.        
언리얼엔진과 같이 런타임에 타입 정보를 가져올 수 있고, dynamic_cast 없이 안전한 타입 캐스팅을 구현하였다.     
필자가 제시하는 방법이 절대 최선의 방법은 아니고 직접 고안한 방식이다보니 허점이 많을 수도 있다.       

아래는 필자가 작성한 코드이다.        

[소스코드1](https://github.com/SungJJinKang/ModernDoom2/blob/main/Doom3/Source/Core/DObject/DObject.h)          
[소스코드2](https://github.com/SungJJinKang/ModernDoom2/blob/main/Doom3/Source/Core/DObject/DObjectGlobals.h)       
[소스코드3](https://github.com/SungJJinKang/ModernDoom2/blob/main/Doom3/Source/Core/DObject/DObjectMacros.h)        
[소스코드4](https://github.com/SungJJinKang/ModernDoom2/blob/main/Doom3/Source/Core/DObject/DClass.h)