---
layout: post
title:  "부동소수점"
date:   2021-08-26
categories: ComputerScience
---

본격적으로 부동소수점에 들어가기전 유리수를 이진수로 변환하는 방법을 먼저 알아보자.
```
ex) 125.3

정수부
64 + 32 + 16 + 8 + 4 + 1 -> 1111101

소수부
0.3 x 2 = 0.6 (0) ( 0 X 2^-1 )
0.6 x 2 = 1.2 (1) ( 1 X 2^-2 )
0.2 x 2 = 0.4 (0) ( 0 X 2^-3 )
0.4 x 2 = 0.8 (0) ( 0 X 2^-4 )
0.8 x 2 = 1.6 (1) ( 1 X 2^-5 )  (첫번째 결과의 소수점과 동일하므로 중단)

result: 01001 01001 01001 .......

125.3 = 1111101.01001
```

알아야 할 것은 위에서 보이듯이 10진수의 유리수를 컴퓨터의 2진수 체계에서는 완벽하게 표현할 수 없다. ( 소수부가 2진수로는 계속해서 무한 반복된다 )                

부동소수점에 대해 깊이 들어가기 전에 왜 부동소수점이 필요한지를 알아야한다.         
컴퓨터에서 소수를 표현하는 방법은 고정소수점과 부동소수점 방식이 있다.       
고정소수점은 정수부와 소수부에 같은 사이즈의 비트를 할당한다는 것이다.      
비트수는 총 11개의 비트가 할당되어서 가장 왼쪽 1개의 비트는 양수인지 음수인지, 그 다음 5개의 비트는 정소부, 그 다음 5개의 비트는 소수부를 나타낸다고 하자.            
예를 들면 1.3063 ( 1.01001110011010011010111 )를 고정소수점으로 표현해보자. 그럼 0 | 00001 | 01001 와 같을 것이다. 여기서 보이는 문제는 소수부 3063 ( 01001110011010011010111 )가 제대로 표현이 되지 않았다는 것이다. 실제 .3063의 이진수는 01001110011010011010111 이나 소수부에 5개의 비트밖에 사용할 수 없어 표현하고자 하는 소수를 제대로 표현하지 못한 것이다.    

그래서 나온 것이 **부동소수점**이다. 부동소수점은 위에서 볼 수 있는 문제를 해결하기 위해 정수부와 소수부로 나누는 것이 아니라 지수와 가수로 나누는 것이다.      
**지수부는 가수부의 시작으로부터 소수부의 시작을 나타내는 점(.)이 얼마나 떨어져있는지.**         
**가수부는 유리수의 숫자들을 나타낸다.**         

그래서 **지수부에 할당된 비트 수를 조절하여 수의 범위를 조절할 수 있고**, **가수부에 할당된 비트 수를 수 정확도를 조절할 수 있다**.           

그래서 1.01001110011010011010111 * 2^0의 지수부 0, 가수부 101001110011010011010111 나누어서 11개의 비트 중 맨 왼쪽 1비트는 그 다음 3비트는 지수부 마지막 7비트는 가수부로 사용한다 ( 아직까지는 예시니 실제 부동소수점과 달라도 그냥 넘어가자 ). 그럼 1 | 000 | 010011 로 고정소수점 방식의 소수부 ( 01001 )에 비해 부동소수점 방식의 소수부 ( 010011 )가 소수부의 정밀도가 높아진 것을 볼 수 있다. 다만 부동소수점에도 문제가 있는 것이 현재 예시의 경우를 보면 정수 부분이 커지면 커질수록 소수부의 정밀도가 떨어지게 되는 문제가 있다. 만약 11.3063를 부동소수점으로 나타낸다고 하면 1.01101001110011010011010111 * 2^3일 것이고 이를 지수부와 가수부로 나누면 1 | 011 | 011010일 것이다. 보시다 싶이 정수부의 11이 (1)011 3개의 비트를 차지하면서 소수부는 010 이렇게 3개의 비트수로 적은 수의 비트 수로 표현된 것을 알 수 있다.       
      
이와 같이 **부동소수점**은 **정수부의 크기에 따라 상대적으로 소수부의 정밀도가 달라지는 특징**(정수부가 커질 수록 소수부의 정밀도는 떨어진다)을 가지고 있다. 그리고 이는 고정소수점에 비해 부동소수점이 일반적으로 소수부를 더 정밀하게 표현할 수 있다는 장점을 말해준다.                      
( 여기에 지수부에는 bias를 더해주고 하는 등의 여러 추가적인 것들이 필요한데 이 글에서는 그냥 넘어가겠다. )        

부동소수점의 위와 같은 특징들 때문에 0.1 + 0.2는 0.3이 아니다.      
0.1의 경우 부동소수점에서는 0 01111011 10011001100110011001101 이다.      
0.2의 경우 부동소수점에서는 0 01111100 10011001100110011001101 이다.     
**컴퓨터의 2진수 체계가 유리수를 정확히 표현하지 못하기 때문에 0.1 + 0.2는 3.0000000000000004가 된다.**            
다만 프로그래밍을 해서 출력을 하면 .0000000000000004와 같은 오차는 반올림해서 출력된다.     

여기서 알 수 있는 것은 10진수 체계에서 0.1은 1 X 10^-1로 완벽히 표현 가능하지만 컴퓨터의 2진수 체계로는 완벽히 표현할 수 없다는 점이다.         
0.3의 경우에는 10진수 체계에서도 완벽히 표현할 수 없다. 0.333333333.......              
이것이 **반올림 오차**라는 것이고 **컴퓨터의 자원은 한정되어 있기 때문에 그 유리수들의 정밀도도 한정되어 있다**.     
이 때문에 일반적으로는 23bit까지만 표현한다( IEEE 754 ). 그리고 그 뒤 숫자들은 반올림한다.                    

반면 0.5와 같은 수의 경우 1 / 2 ( = 2^-1 )로 2진수로 완벽하게 표현이 되어 부동소수점으로는 0 01111111110 00000000000000000000000 으로 표현된다. 보시다 싶이 가수부가 모두 0이다.       

이렇게 유리수를 정확히 표현하지 못하는 2진수의 특징 때문에 같아 보이는 연산의 결과가 다르다고 나타날 수도 있다.        
```   
float a = 0.15 + 0.15
float b = 0.1 + 0.2
if(a == b) // 거짓일 수 있다.    
if(a >= b) // 이것 또한 거짓일 수 있다.    
```           
 
위의 a와 b의 값은 상식적으로 보면 같아야 정상이지만 유리수를 정확히 표현하지 못하는 2진수의 특징 때문에 실제로는 비트 구성이 같지 않을 수 있다.      

또한 매우 큰 유리수 100,000,000와 유리수 1을 부동소수점으로 더하면 결과가 100,000,000 그대로일 수 있다. 이 또한 부동소소수점에서 매우 큰 수에 고작 1이라는 작은 수를 더한 결과가 반올림 된 후 가수부 23 bit에는 변화를 주지 않기 때문이다.          

이 글에서는 부동소수점을 계산하는 방법은 제외되어 있으니 그에 대한 내용은 아래의 링크에서 확인하기 바란다.     

references : [https://floating-point-gui.de/formats/fp/](https://floating-point-gui.de/formats/fp/)              

