---
layout: post
title:  "reflection 시스템을 이용한 C++ 가비지 컬렉터 ( +클러스터링 ) ( 작성 중 )"
date:   2021-12-01
categories: ComputerScience
---

[지난번 만든 reflection 시스템](https://sungjjinkang.github.io/computerscience/gameengine/2021/11/12/reflection.html)을 이용하여 C++ 가비지 컬렉터를 만들 것이다.            

이전에도 [메모리 누수를 방지하기 위한 구조](https://sungjjinkang.github.io/computerscience/gameengine/2021/09/25/dangling_pointer.html)가 존재했지만 이 방법은 씬이 끝나거나 특수한 상황에서 임의로 모든 DObject들을 한꺼번에 회수해주는 기능이라 엄연히 참조가 되지 않은 오브젝트를 주기적으로 회수해주는 가비지 컬렉터와는 역할이 다르다.              

**언리얼 엔진의 가비지 컬렉터**를 생각하면 된다.     
일일이 오브젝트를 파괴(해제)해줄 필요 없이 그냥 포인터를 null로 바꾸어두면 가비지 컬렉터가 알아서 한번도 다른 오브젝트에 의해 참조가 되지 않은 오브젝트들의 메모리를 수거해가는 시스템이다.        


가비지 컬렉터를 위한 보조 기능들은 다 구현이 되어 있어서 금방 만들 것 같다.          

-------------------------------     

처음에는 우선 기능 구현에 집중을 하고 기능이 구현되면 성능을 높여갈 예정이다.        

**기본적인 동작 원리**는 이렇다.           
일정 주기마다 루트 오브젝트를 순회한다.         
루트 오브젝트에서 D_PROPERTY가 선언된 모든 프로퍼티 ( 멤버 변수 )들을 순회한다.          
프로퍼티 타입이 DObject 클래스의 자녀 타입인 경우 해당 오브젝트는 이번 루틴에서 다른 오브젝트에 의해 참조가 되어 있다고 표시한다.              
최종적으로 모든 루트 오브젝트와 그 프로퍼티들을 순회하고 난 후 여전히 다른 오브젝트에 의해 참조가 되지 않은 오브젝트들을 회수 ( 파괴 )해준다.         

일단 필자의 계획은 **순회를 하면서 어떤 오브젝트를 파괴해주어야할지 결정하는 과정은 멀티스레드로 분배해서 수행**할 것이다.       
멀티스레드로 파괴할 오브젝트들이 모두 정해지면 **파괴하는 작업 ( delete )은 싱글 스레드에서 수행**할 것이다. ( 파괴 동작을 멀티스레드로 하려면 고려해야할 변수가 너무 많아진다. )               


-------------------------------     
