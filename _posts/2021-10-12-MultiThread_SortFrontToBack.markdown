---
layout: post
title:  "멀티스레드로 Front to Back Sorting 하기!"
date:   2021-10-12
categories: ComputerScience
---

렌더링시 카메라와 가까운 오브젝트부터 먼 오브젝트순으로 렌더링을 하는 것은 성능 향상에 도움이 된다.      
왜냐면 **카메라와 가까운 오브젝트들로 Depth 버퍼를 그려두면 뒤쪽에 있는 오브젝트들을 그릴 때 Early Depth Test에서 Fragment들을 거를 수 있어서 Fragment Shading 작업을 덜 할 수 있다.**                 
이게 무슨 말이냐면 기본적으로 Fragment의 Depth Test 연산은 Fragment Shading 연산이 끝난 후 진행된다.      
그런데 Fragment Shading 단계에서 Depth 값을 조작하거나 Fragment를 임의로 버리지만 않으면 Rasterization 단계가 끝난 후 각 Fragment들의 Depth 값을 알 수 있다. Fragment Shading은 기본적으로 Vertex의 위치가 바뀌는 작업이 아니기 때문에 이는 당연하다.       
그래서 GPU는 Early Depth Test라는 최적화를 수행해주는데 이는 Rasterization 단계 후 Fragment Shading을 진행하기 전 Depth Test를 수행해서 어차피 안 그려질 ( 어차피 Fragment Shading 후 Depth Test에서 걸러질 ) Fragment를 다음 단계로 넘기지 않는다.           
Fragment Shading에 Fragment가 덜 넘겨지니 당연히 연산은 훨씬 빨라진다.       
더구나나 Fragment Shading은 텍스쳐를 읽거나, Lighting 연산을 하는 등 매우 무거운 작업이기 때문에 Fragment Shading을 덜 하는건 성능 향상에 매우 큰 도움이된다.      

그래서 내 엔진에서도 당연히 렌더링할 오브젝트들의 카메라와의 거리에 따라 정렬을 한 후 GPU에 DrawCall을 때린다.         
다만 무식하게 했었다.       
```
카메라와 렌더링 할 오브젝트의 거리 = (카메라의 위치 - 렌더링 할 오브젝트의 위치).거리 구하기() - 렌더링 할 오브젝트의 Bounding Sphere의 반지름
```
렌더링 할 오브젝트의 Bounding Sphere의 반지름을 고려해주기 때문에 오브젝트가 매우 크다면 그 오브젝트는 가깝다고 판정이 된다.    
이런 식으로 카메라와 렌더링 할 오브젝트의 거리를 구한 후 퀵솔트로 오브젝트들을 거리 순서대로 정렬해준다.         
필자가 알기로는 따로 Tree를 이용해서 여러 오브젝트들을 묶어서 Sorting을 해준다고 들었는데 귀찮기도 하고 렌더링 동안 서브 스레드들이 놀고 있어서 멀티스레드를 이용하기로 결정하였다.    

--------------------------------           

멀티스레드로 구현하기 이전의 원래 구현은 이러했다.       

```
"메인 스레드가" 서브스레드에 "뷰 프러스텀 컬링 작업"을 맡김
->
"메인 스레드는" 모든 오브젝트들의 카메라와의 거리 계산 | "서브 스레드는" 컬링 작업 중
->
"메인 스레드는" 모든 오브젝트들을 위에서 구한 거리 기준으로 정렬 | "서브 스레드는" 컬링 작업 중
->
"메인 스레드는" 서브 스레드에서 컬링 작업을 완료할 때까지 GPU 관련 여러 상태 셋팅
->
"메인 스레드는" Draw API 호출 본격 시작 전 서브스레드가 뷰 프러스텀 컬링 작업 끝나기를 기다림 ( 메인 스레드가 기다리는 시간이 거의 제로에 가까움 )
->
"메인 스레드는" 서브 스레드의 컬링 연산이 끝나면 컬링된 오브젝트를 제외한 오브젝트들을 위에서 구한 정렬된 순서로 Draw API 호출 | 서브 스레드들은 놀아요 여기서... 
```

여기서 가장 느리고 동작했던 부분은 "모든 오브젝트들의 카메라와의 거리 계산", "모든 오브젝트들을 위에서 구한 거리 기준으로 정렬" 이 부분이었다.    
그래서 필자는 이 Front to Back Sorting을 위한 두 작업에서 멀티스레드를 활용하여 프레임을 높이기로 결정하였다.     

-------------------------------



**우선 "모든 오브젝트들의 카메라와의 거리 계산", "모든 오브젝트들을 위에서 구한 거리 기준으로 정렬" 두 부분을 모두 "서브스레드에 뷰 프러스텀 컬링 작업"을 하면서 같이 하도록 코드를 작성해보았다.**              

```
"메인 스레드는" 서브스레드에 "뷰 프러스텀 컬링 작업" + "오브젝트와 카메라와의 거리 계산" + "계산한 거리를 기준으로 정렬" 작업을 맡김 
->
"메인 스레드는" 서브 스레드가 3가지 작업을 완료할 때까지 GPU 관련 여러 상태 셋팅 | "서브 스레드는" "뷰 프러스텀 컬링 작업" + "오브젝트와 카메라와의 거리 계산" + "계산한 거리를 기준으로 정렬" 작업 중
->
"메인 스레드는" Draw API 호출 본격 시작 전 서브스레드가 뷰 프러스텀 컬링 작업 끝나기를 기다림 ( 메인 스레드가 기다리는 시간이 거의 제로에 가까움 )
->
"메인 스레드는" 서브 스레드의 3가지 작업이 끝나면 컬링된 오브젝트를 제외한 오브젝트들을 위에서 구한 정렬된 순서로 Draw API 호출 | "서브 스레드들은" 놀아요 여기서...
```

이렇게 구현을 하니 **문제는 "서브 스레드가 작업을 다 끝날 때까지" 시간이 많이 걸려서 "메인스레드가 뷰 프러스텀 컬링 작업 끝날 때까지 대기"하는 시간이 너무 많이 걸렸다.**            
"모든 오브젝트들의 카메라와의 거리 계산"은 여러 서브스레드에 균등하게 분배를 할 수 있다고 쳐도 **"모든 오브젝트들을 위에서 구한 거리 기준으로 정렬"하는 작업은 한 스레드가 맡아서 해야했다"**          
물론 **분할 정복으로 오브젝트들을 몇개씩 묶어서 서브스레드에 맡긴 후 합친 후 정렬을 해나가면** 가능은 할 것 같았지만 코드가 너무 복잡해지고 결국 **정렬이라는 것이 쓰기 동작인데 False Sharing 문제 등 캐시 동기화로 인한 성능 저하가 생길 것 같았다.**            

--------------------------------           

그래서 **다른 방법**을 찾은 것이 **"모든 오브젝트들의 카메라와의 거리 계산"은 서브스레드에서 컬링 작업을 하면서 같이 하고** ( 컬링 작업을 하면서 카메라와 렌더링 할 오브젝트의 위치 값에 접근해야했기 때문에 "컬링"과 "오브젝트와 카메라와의 거리 계산"을 같이 하는 것이 캐시 측면에서도 유리하다. ), **Front To Back Sorting 연산은 메인 스레드가 Draw API를 호출하는 동안 한개의 서브스레드에서 수행하는 것이다.**       

그럼 위에서 말한 서브스레드들이 "모든 오브젝트들의 카메라와의 거리 계산", "모든 오브젝트들을 위에서 구한 거리 기준으로 정렬" 두 부분을 모두 "서브스레드에 뷰 프러스텀 컬링 작업"을 하면서 같이하는 방법과 비교해, "모든 오브젝트들을 위에서 구한 거리 기준으로 정렬" 연산이 빠지니 "메인스레드가 뷰 프러스텀 컬링 작업 끝날 때까지 대기"하는 시간을 거의 제로로 유지할 수 있었다.        

그러니깐 대충 순서가 이러하다.          
```
"메인 스레드는" 서브스레드에 뷰 프러스텀 컬링 작업 + 오브젝트와 카메라와의 거리 계산을 맡김
->
"메인 스레드는" 서브 스레드가 2가지 작업을 완료할 때까지 GPU 관련 여러 상태 셋팅 | "서브 스레드는" 컬링 작업 + 오브젝트와 카메라와의 거리 계산 중
->
"메인 스레드는" 서브스레드가 뷰 프러스텀 컬링 작업 끝날 때까지 대기 ( 메인 스레드가 기다리는 시간이 거의 제로에 가까움 )
->
"메인 스레드는" 서브스레드가 컬링 연산이 끝나면 컬링된 오브젝트를 제외하고 정렬된 순서로 Draw API 호출 | "서브스레드는" 오브젝트들을 위에서 서브스레드가 연산한 카메라와의 거리를 기준으로 Front To Back Sorting 연산을 수행
```

이 방법은 **메인 스레드가 오브젝트들에 대한 Draw API를 호출하는 동안, 놀고 있는 서브스레드에게 Front to Back Sorting을 맡긴다**는점에서 멀티스레드의 이점을 얻을 수 있다.            
**문제**가 있었는데 메인 스레드가 오브젝트들에 대한 Draw API를 호출을 할 때 **렌더러 컴포넌트들을 모아둔 리스트**를 순회를 하면서 API를 호출을 한다는 것이다. 이것이 왜 문제냐면 그떄 서브스레드가 Front To Back Sorting을 하는데 이 Sorting이 **렌더러 컴포넌트들을 모아둔 리스트**에 대해 Sorting을 한다는 것이다.         
그럼 메인 스레드가 Draw API 호출을 위해 **렌더러 컴포넌트들을 모아둔 리스트**를 순회를 하는 동안 **서브 스레드가 정렬을 수행하며 그 리스트의 순서를 바꿀 수도 있다**는 것이다.        
그래서 그냥 **리스트를 두개**를 만들었다. **메인 스레드가 순회를 하는 리스트를 Working 리스트**, 그 동안 **서브 스레드가 정렬을 수행하는 리스트는 Sorting 리스트**라고 이름 붙였다.         

그럼 한 프레임 후 렌더링을 시작할 때는 **기존의 Sorting 리스트는 오브젝트들의 한 프레임 전 위치 값을 기준으로 정렬**이 되어 있을 것이고, **Working 리스트는 오브젝트들의 두 프레임 전 위치 값을 기준으로 정렬**이 되어 있을 것이다.            
그럼 이 때 **Working 리스트와 Sorting 리스트를 서로 바꾼다.** ( 물론 실제로 데이터를 옮기지는 않고 그냥 접근만 다른 리스트로 접근하는 것이다. )       
그럼 최소한 **현재 렌더링을 하는 오브젝트들의 리스트 ( 지난 프레임에 Sorting 리스트였던, 현재 프레임에서는 Working 리스트인 )는 오브젝트들의 지난 프레임의 위치 값을 기준으로 정렬이 되어 있을 것**이다.            
이 정도면 **용인 가능**하다. 한 프레임 동안 오브젝트 순서가 바뀌어바야 얼마나 바뀌겠는가. **그냥 한 프레임 전 기준으로 정렬된 순서대로 렌더링해도 크게 문제가 될 것이 없다.**      

메인 스레드에서 Working 리스트를 가지고 순회를 하며 그래픽 API를 호출하는 동안, 서브스레드는 Sorting 리스트에 대해 Front To Back 정렬을 수행한다.      




그래서 멀티스레드로 Sorting을 수행한 결과는 무려 **6ms** 빨라졌다.           
Front Back Sorting을 아예 수행하지 않았을 때 ( 이 경우 GPU가 고생한다 )에 비하면 1ms 느려졌다. 이 정도면 굉장한 성과이다.     
매우 만족하는 결과이다 ^^            

