---
layout: post
title:  "C++ 실수 줄이기 시리즈"
date:   2021-02-26
categories: C++
---

이 글은 내가 C++ 코드를 작성하면서 실수를 줄이고 실수로 발생하는 memory leak을 막기 위해 하였던 여러 방법들과 RAII기법들을 소개하고자한다.  

--------------------------------------

## 스마트 포인터를 적극 활용하자.    

두말하면 입 아프다 스마트 포인터는 실수가능성을 줄여줘 무심코 생기는 memory leak을 줄여준다.      

--------------------------------------

## vector은 무조건 reserve하자.      
   
std::vector을 생성할 때 "std::vector(1000)" 이런 식으로 vector을 생성하는 것은 정말 미친 짓이다.        
1000개의 item을 위한 메모리를 할당 후 모든 item에 대해 default-initilization을 하기 때문이다.     
물론 이 동작을 원하는 경우에는 상관없다.                   
```c++
std::vector<int> a(1000); // 1000개의 int item을 모두 0으로 초기화
```

무조건 "std::vector.reserve"를 사용하자. std::vector.reserve는 메모리 할당은 하지만 initialization을 수행하지 않는다.                
```c++
std::vector<int> variable;
variable.reserve(1000);
```

--------------------------------------

## enum class를 사용하자.      

enum class를 사용하자. 무심코 형변환하는 일이 없어진다. enum을 사용했을 때와 enum class를 static_cast로 변환하여 사용하였을 때 오버헤드의 차이는 전혀 없다. 필자의 이전 글을 읽어보면 자세한 내용이 나와있다.      

--------------------------------------

## 클래스의 모든 멤버변수의 move, copy semantic을 잘 정의하고 클래스는 그냥 =default를 통해 컴파일러가 만들어주는 move, copy semantic을 사용하려 노력하자.       

클래스의 move, copy semantic을 프로그래머가 직접 작성하는 것은 여간 귀찮은 일이 아니고 또한 실수할 시 memory leak이 발생할 가능성도 크다. 그래서 필자는 최대한 클래스의 copy, move semantic을 컴파일러가 자동으로 만들어 주는 것을 사용하려 노력한다. 그렇지만 이를 위한 요구조건이 있는 데 해당 클래스의 모든 멤버변수가 move, copy semantic을 가지고 있어야한다. 클래스를 짤 때 처음에 move, copy semantic을 잘 구성해두면 나중에 귀찮은 일이 현저히 줄어든다.            

--------------------------------------


