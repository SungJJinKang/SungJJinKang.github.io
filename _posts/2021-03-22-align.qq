---
layout: post
title:  "SIMD(SSE) 사용하기"
date:   2021-03-22
categories: Doom
---

렌더링을 하는 데 ModelMatirx나 AABB등에 ModelMatrix를 적용하는 데 너무 많은 부화가 걸린다. 그래픽 API 콜보다 더 많은 부하가 걸려서 이걸 해결해야겠다는 생각이 들었다.    
당연히 필자는 SIMD(SSE)를 찾아보았고 마침내 적용해보기로 하였다. SIMD를 잘만 적용하면 엄청난 성능향상이 오는 것으로 알 고 있다.   
SIMD에 대해 살짝 간을 봤는 데 쉽지는 않을 것 같다.     

우선 SIMD 명령어를 컴파일러가 인식하기 위해서는 컴파일러 설정에서 SIMD를 셋팅해줘야하는 데 Visual Studio는 Project Setting -> C/C++ -> Code Generation -> Enable Enhanced Instruction Set에서 설정해주면 된다.    
필자는 AVX1 버전까지 지원하기로 결정하였다. AVX2는 아직까지는 지원하지 않는 CPU가 조금 있고 필자가 조사한 바로는 상용게임들도 AVX1까지 지원한다고 알고 있다. 물론 매크로로 AVX2까지 지원해줄 수도 있지만 필자는 귀찮기도하고 AVX1까지 지원하기로 결정하였다.    
AVX1은 그 하위버전인 SSE, SSE2, SSE3 ....들을 모두 포함하고 있다.       

우선 본격적으로 시작하기 전 SIMD의 결과값을 받을 16바이트로 Aligned된 Vector4 구조체를 간단하게 만들었다. SIMD는 XMM이라는 전용 레지스터를 통해 데이터를 읽어오거나 쓰는 데 이 XMM 레지스터는 128byte로 효율적인 

```c++
typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;
```

```c++
template <typename T>
struct Aligned16Vector4
{
    __declspec(align(16)) T data[4];
};
```
이 결과값을 Aligned로 받는 다는 조건 때문에 SIMD가 오히려 느린 경우가 발생한다. 기본적으로 게임 내 사용되는 Vector형의 데이터는 packed되어 있다. Vector형 자체는 aligned되어 있을지 몰라도 그 내부 데이터는 packed되어 있다. 아래는 필자가 사용하는 Vector형의 아주 간단한 버전이다.    
```c++
struct Vector4
{
    union { float x, r; };
    union { float y, g; };
    union { float z, b; };
    union { float w, a; };
}
```
그럼 생각해보자. SIMD를 사용하려면 SIMD의 결과값을 16byte

SIMD가 연산할 때 사용하는 XMM 레지스터는 12Bit로 이루어줘 효율적으로 데이터를 전송하고 읽어오기 위해서는 128bit 즉 16byte로 결과값을 읽어오는 변수가 aligned되어 있어야한다. ( aligned에 대해서는 나중에 포스팅을 올릴 예정이다 )         







reference :           
https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX    
https://software.intel.com/sites/landingpage/IntrinsicsGuide     