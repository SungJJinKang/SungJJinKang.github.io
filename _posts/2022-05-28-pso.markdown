---
layout: post
title:  "UE4 PSO(Pipeline State Object) Cache ( OpenGL 위주로 )"
date:   2022-05-28
categories: UnrealEngine4 UE4 ComputerScience ComputerGraphics
---

PSO란 하나의 Draw를 위해 필요한 여러 렌더링의 상태들을 말한다.          
모든 셰이더 바이트 코드, Blend 스테이트, Rasterizer 스테이트, DepthStencil 스테이트, Multi-sampling 정보 등등이 PSO에 속한다.            

Draw가 바뀔 때마다 PSO도 달라질 가능성이 높다.            
PSO가 달라질 때마다 PSO를 새로 생성하는 것은 매우 느려터진 동작이다.             
그러니 한번 생성해두었던 PSO는 캐싱해두고 다음 번에 다시 사용한다.          
UE4는 런타임에 생성한 PSO를 버리지 않고 캐싱해두었다가, 다시 사용한다.             

UE4 여기서 더 나아가 이러한 PSO를 디스크에 써두었다가, 게임 시작시 미리 컴파일해둔다.     
개발사가 미리 수집하여 배포한 PSO를 유저가 게임 시작이 컴파일하여 런타임에 사용할 각 API에 맞는 PSO 오브젝트를 생성해서 캐싱해두는 것이다.             
D3D12 / Vulkan / Metal의 경우 렌더 스테이트와, 쉐이더 스테이트들에 대한 캐싱을 지원한다. 또한 PSO를 통해 렌더 스테이트와, 쉐이더 스테이트를 일괄적으로 한번에 갱신할 수 있다.                  
반면 OpenGL의 경우에는 바운드된 쉐이더 스테이트(BSS)에 대한 캐싱만을 지원하고, 렌더 스테이트와, 쉐이더 스테이트를 각각 따로 갱신해야한다.    

자세한건 [이 자료](https://unrealsummit16.cafe24.com/replay/pdf/USM20190514_1_5_How%20to%20use%20shader%20pipeline%20cache.pdf)를 참고하자.


-------------------------------

이제 OpenGL의 PSO 캐시를 위주로 살펴보겠다.        
위에서 말했듯이 **OpenGL은 바운드된 쉐이더 스테이트(BSS, FRHIBoundShaderState)에 대한 캐싱만 지원**한다.          
**바운드된 쉐이더 스테이트에는 각 Stage별 쉐이더 코드들과 그 조합들**이 들어 있다.          
개발사에서 PSO를 수집하며 한번이라도 사용되었던 쉐이더 코드를 BSS에 담아 배포시 함께 배포한 후 유저는 개발사에서 배포한 PSO에 담겨 있는 쉐이더 코드를 Pre Compile하여 아래에 나올 Program Binary의 형태로 보관하거나 미리 Program 오브젝트를 만들어 두는 것이다.             
               
**OpenGL의 경우 컴파일한 쉐이더를 드라이버에서 관리하는 Program 객체에 Link한 후 바인딩해서 Draw에 사용**한다.        
**바운드된 쉐이더 스테이트(BSS)는 이 Program 객체에 플랫폼 독립적인 버전**이다.       
           
Draw에 사용 될 각 Stage의 모든 쉐이더 ( 버텍스 쉐이더, 픽셀 쉐이더, Hull 쉐이더 등등.... )를 하나의 Program 객체에 Link한 후 이 Program 객체를 바인딩하는 것이다. OpenGL은 Global State로 렌더링, 쉐이더를 관리하기 때문에 쉐이더가 바뀌면 그때 그때마다 새로운 Program을 바인딩 해주어야한다.       
( PC에서는 [Seperate Shader Object](https://www.khronos.org/opengl/wiki/Shader_Compilation#Separate_programs)라는 개념을 지원해서, 각 Stage별 쉐이더를 별개의 Program에 링크하여 사용할 수 있게 지원한다. 어느 특정 Stage에 링크된 Program를 조합하여 사용할 수 있는 것이다. )         
            
OpenGL은 [이렇게 쉐이어들이 링크된 Program 객체를 바이너리 형태로 보관](https://www.khronos.org/opengl/wiki/Shader_Compilation#Binary_upload)할 수 있게 지원해준다.        
           
Program 객체를 바이너리 형태로 메모리나, 디스크에 보관해두었다가, 이 바이너리 데이터를 가지고 GPU 드라이버에 Program 객체를 생성해줄 것을 요청할 수 있다. Program 오브젝트에 일일이 쉐이더를 링크하는 것에 비해 훨씬 빠르다.                 
이 Program 객체의 포맷은 GPU Vendor마다 다르고, GPU 드라이버마다 다르고, 휴대폰마다 달라서 개발사에서 배포할 수는 없다. 심지어는 같은 휴대폰으로도 휴대폰 업데이트 후 Program 객체의 포맷이 달라져서 기존의 Program 바이너리를 재사용할 수 없는 경우도 생긴다.             
그래서 **UE4에서는 개발사에서 배포한 PSO에 담긴 바운드된 쉐이더 스테이트를 가지고 PreCompile하여 그 과정에서 Program 오브젝트를 생성하고 쉐이더를 링크한 후 Program Binary를 디스크에 보관한다. 이미 디스크에 Program Binary가 존재하는 경우 이 Program Binary로부터 곧 바로 Program 오브젝트를 생성**해낸다.          
**바운드된 쉐이더 스테이트(PSO 캐시)는 개발사에서 수집하여 앱 배포시 함께 배포하지만, Program 오브젝트의 Binary는 유저의 기기에서 직접 생성하여 보관**해두는 것이다.          
             
또한 Program 오브젝트 자체도 매번 새로 생성하는 것이 아니라 캐싱을 해두는데, 문제는 모바일 디바이스에서 GPU에 따라서 너무 많은 Program 오브젝트를 생성한 경우 문제가 될 수 도 있다는 것이다.       
일부 모바일 GPU의 경우 쉐이더 메모리 ( 위에서 말했듯이 Program 오브젝트는 드라이버에서 관리한다. )가 작기 때문에 너무 많은 Program 오브젝트를 생성하면 텍스쳐가 깨지는 등의 문제가 발생한다.          
그래서 UE4는 Program 오브젝트에 대한 LRU 캐싱 정책을 지원한다. 생성한 Program 오브젝트의 사이즈가 일정 사이즈보다 커지는 경우 사용하지 않은지 오래된 Program 오브젝트를 파괴하는 것이다. ( r.OpenGL.EnableProgramLRUCache )            
이렇게 Evict한 Program 오브젝트에 대한 Program Binary를 시스템 메모리에 보관할 수도 있다. ( r.OpenGL.ProgramLRUKeepBinaryResident )         
           
요약하자면          
           
1. 개발사는 PSO 수집을 하며 한번이라도 사용된 쉐이더 조합 ( 한 Program 오브젝트에 같이 링크된 쉐이더들의 조합 )을 BSS의 형태로 PSO 캐시 파일에 담아 유저들에게 배포한다.
2. 유저들은 최초 앱 구동시 PSO에 담긴 BSS 데이터를 가지고 쉐이더들을 컴파일하고, Program 오브젝트 생성 후 링크시켜서 하나의 온전한 Program 오브젝트를 만든다. 그리고 이 Program 오브젝트의 Binary 데이터를 유저의 기기 디스크에 저장해둔다. ( Program Binary는 위에서 말했듯 기기마다 포맷이 다르기 때문에 개발사가 배포할 수 없고 유저 기기에서 직접 만들어서 보관해두어야한다. ) 그리고 이를 PreCompile한다고 말한다.
3. 유저가 이후 앱을 구동할 때는 앱 시작시 최초 구동 때 디스크에 저장해두었던 Program Binary로부터 곧 바로 Program 오브젝트를 생성한다. 당연히 이 Program 오브젝트는 캐싱해두었다가 게임을 플레이하는 동안 가져와서 사용한다. ( 런타임에 Program 오브젝트를 생성하고 링크하는 비용이 들지 않는 것이다. )
4. 또한 유저가 플레이하면서 새로운 ( 캐싱되어 있지 않은 ) 쉐이더 조합 ( Program 오브젝트 )을 발견하면 이 Program 오브젝트의 Binary 또한 디스크에 캐싱을 해둔다.
               
```cpp
// ⭐⭐⭐⭐⭐⭐⭐
// 디스크에서 읽어온 PSO를 PreCompile한다.
bool FShaderPipelineCache::Precompile(FRHICommandListImmediate& RHICmdList, EShaderPlatform Platform, FPipelineCacheFileFormatPSO const& PSO)
// ⭐⭐⭐⭐⭐⭐⭐
{
	INC_DWORD_STAT(STAT_PreCompileShadersTotal);
	INC_DWORD_STAT(STAT_PreCompileShadersNum);
    
    uint64 StartTime = FPlatformTime::Cycles64();

	bool bOk = false;
	
	if(PSO.Verify())
	{
		if(FPipelineCacheFileFormatPSO::DescriptorType::Graphics == PSO.Type)
		{
            // ⭐
            // FGraphicsPipelineStateInitializer는 플랫폼에 의존적이지 않은 PSO 데이터 객체이다.
			FGraphicsPipelineStateInitializer GraphicsInitializer;
            // ⭐
			
			FRHIVertexDeclaration* VertexDesc = PipelineStateCache::GetOrCreateVertexDeclaration(PSO.GraphicsDesc.VertexDescriptor);
			GraphicsInitializer.BoundShaderState.VertexDeclarationRHI = VertexDesc;
			
			FVertexShaderRHIRef VertexShader;
			if (PSO.GraphicsDesc.VertexShader != FSHAHash())
			{
				VertexShader = FShaderCodeLibrary::CreateVertexShader(Platform, PSO.GraphicsDesc.VertexShader);
				GraphicsInitializer.BoundShaderState.VertexShaderRHI = VertexShader;
			}

	#if PLATFORM_SUPPORTS_TESSELLATION_SHADERS
			FHullShaderRHIRef HullShader;
			if (PSO.GraphicsDesc.HullShader != FSHAHash())
			{
				HullShader = FShaderCodeLibrary::CreateHullShader(Platform, PSO.GraphicsDesc.HullShader);
				GraphicsInitializer.BoundShaderState.HullShaderRHI = HullShader;
			}

			FDomainShaderRHIRef DomainShader;
			if (PSO.GraphicsDesc.DomainShader != FSHAHash())
			{
				DomainShader = FShaderCodeLibrary::CreateDomainShader(Platform, PSO.GraphicsDesc.DomainShader);
				GraphicsInitializer.BoundShaderState.DomainShaderRHI = DomainShader;
			}
	#endif
			FPixelShaderRHIRef FragmentShader;
			if (PSO.GraphicsDesc.FragmentShader != FSHAHash())
			{
				FragmentShader = FShaderCodeLibrary::CreatePixelShader(Platform, PSO.GraphicsDesc.FragmentShader);
				GraphicsInitializer.BoundShaderState.PixelShaderRHI = FragmentShader;
			}

	#if PLATFORM_SUPPORTS_GEOMETRY_SHADERS
			FGeometryShaderRHIRef GeometryShader;
			if (PSO.GraphicsDesc.GeometryShader != FSHAHash())
			{
				GeometryShader = FShaderCodeLibrary::CreateGeometryShader(Platform, PSO.GraphicsDesc.GeometryShader);
				GraphicsInitializer.BoundShaderState.GeometryShaderRHI = GeometryShader;
			}
	#endif
			auto BlendState = GetOrCreateBlendState(PSO.GraphicsDesc.BlendState);
			GraphicsInitializer.BlendState = BlendState;
			
			auto RasterState = GetOrCreateRasterizerState(PSO.GraphicsDesc.RasterizerState);
			GraphicsInitializer.RasterizerState = RasterState;
			
			auto DepthState = GetOrCreateDepthStencilState(PSO.GraphicsDesc.DepthStencilState);
			GraphicsInitializer.DepthStencilState = DepthState;

			for (uint32 i = 0; i < MaxSimultaneousRenderTargets; ++i)
			{
				GraphicsInitializer.RenderTargetFormats[i] = PSO.GraphicsDesc.RenderTargetFormats[i];
				GraphicsInitializer.RenderTargetFlags[i] = PSO.GraphicsDesc.RenderTargetFlags[i];
			}
			
			GraphicsInitializer.RenderTargetsEnabled = PSO.GraphicsDesc.RenderTargetsActive;
			GraphicsInitializer.NumSamples = PSO.GraphicsDesc.MSAASamples;

			GraphicsInitializer.SubpassHint = (ESubpassHint)PSO.GraphicsDesc.SubpassHint;
			GraphicsInitializer.SubpassIndex = PSO.GraphicsDesc.SubpassIndex;
			
			GraphicsInitializer.DepthStencilTargetFormat = PSO.GraphicsDesc.DepthStencilFormat;
			GraphicsInitializer.DepthStencilTargetFlag = PSO.GraphicsDesc.DepthStencilFlags;
			GraphicsInitializer.DepthTargetLoadAction = PSO.GraphicsDesc.DepthLoad;
			GraphicsInitializer.StencilTargetLoadAction = PSO.GraphicsDesc.StencilLoad;
			GraphicsInitializer.DepthTargetStoreAction = PSO.GraphicsDesc.DepthStore;
			GraphicsInitializer.StencilTargetStoreAction = PSO.GraphicsDesc.StencilStore;
			
			GraphicsInitializer.PrimitiveType = PSO.GraphicsDesc.PrimitiveType;
			GraphicsInitializer.bFromPSOFileCache = true;
			
            // ⭐
            // PSO PreCompile에서 SetGraphicsPipelineState를 호출한다는 것을 명시한다.
			// This indicates we do not want a fatal error if this compilation fails
			// (ie, if this entry in the file cache is bad)
			GraphicsInitializer.bFromPSOFileCache = 1;
            // ⭐
			
            // ⭐⭐⭐⭐⭐⭐⭐
            // PSO PreCompile은 그냥 PSO를 한번 셋팅함으로서 이루어진다.
			// Use SetGraphicsPipelineState to call down into PipelineStateCache and also handle the fallback case used by OpenGL.
			SetGraphicsPipelineState(RHICmdList, GraphicsInitializer, EApplyRendertargetOption::DoNothing, false);
            // ⭐⭐⭐⭐⭐⭐⭐

			bOk = true;
		}
		else if(FPipelineCacheFileFormatPSO::DescriptorType::Compute == PSO.Type)
		{
			FComputeShaderRHIRef ComputeInitializer = FShaderCodeLibrary::CreateComputeShader(Platform, PSO.ComputeDesc.ComputeShader);
			if(ComputeInitializer.IsValid())
			{
				FComputePipelineState* ComputeResult = PipelineStateCache::GetAndOrCreateComputePipelineState(RHICmdList, ComputeInitializer);
				bOk = ComputeResult != nullptr;
			}
		}
		else
		{
			check(false);
		}
	}

    // All read dependencies have given the green light - always update task counts
    // Otherwise we end up with outstanding compiles that we can't progress or external tools may think this has not been completed and may run again.
    {
        uint64 TimeDelta = FPlatformTime::Cycles64() - StartTime;
        FPlatformAtomics::InterlockedIncrement(&TotalCompleteTasks);
        FPlatformAtomics::InterlockedAdd(&TotalPrecompileTime, TimeDelta);
    }
	
	return bOk;
}
```


```cpp
virtual void RHISetGraphicsPipelineState(FRHIGraphicsPipelineState* GraphicsState, bool bApplyAdditionalState) final override
	{
		FRHIGraphicsPipelineStateFallBack* FallbackGraphicsState = static_cast<FRHIGraphicsPipelineStateFallBack*>(GraphicsState);

		auto& PsoInit = FallbackGraphicsState->Initializer;

        // ⭐⭐⭐⭐⭐⭐⭐
        // 바운딩된 쉐이더 스테이트 ( BSS )를 생성한다.
        // 개발사가 수집해서 유저들에게 배포하는 PSO 캐시가 이것이다.
        // 
		RHISetBoundShaderState(
			RHICreateBoundShaderState_internal(
				PsoInit.BoundShaderState.VertexDeclarationRHI,
				PsoInit.BoundShaderState.VertexShaderRHI,
				TESSELLATION_SHADER(PsoInit.BoundShaderState.HullShaderRHI),
				TESSELLATION_SHADER(PsoInit.BoundShaderState.DomainShaderRHI),
				PsoInit.BoundShaderState.PixelShaderRHI,
				GEOMETRY_SHADER(PsoInit.BoundShaderState.GeometryShaderRHI),

                // ⭐
                // 위에서 1로 셋팅했다.
				PsoInit.bFromPSOFileCache
                // ⭐
			).GetReference()
		);
        // ⭐⭐⭐⭐⭐⭐⭐

		RHISetDepthStencilState(FallbackGraphicsState->Initializer.DepthStencilState, 0);
		RHISetRasterizerState(FallbackGraphicsState->Initializer.RasterizerState);
		RHISetBlendState(FallbackGraphicsState->Initializer.BlendState, FLinearColor(1.0f, 1.0f, 1.0f));
		if (GSupportsDepthBoundsTest)
		{
			RHIEnableDepthBoundsTest(FallbackGraphicsState->Initializer.bDepthBounds);
		}

		if (bApplyAdditionalState)
		{
			ApplyGlobalUniformBuffers(PsoInit.BoundShaderState.VertexShaderRHI, ResourceCast(PsoInit.BoundShaderState.VertexShaderRHI));
			ApplyGlobalUniformBuffers(PsoInit.BoundShaderState.HullShaderRHI, ResourceCast(PsoInit.BoundShaderState.HullShaderRHI));
			ApplyGlobalUniformBuffers(PsoInit.BoundShaderState.DomainShaderRHI, ResourceCast(PsoInit.BoundShaderState.DomainShaderRHI));
			ApplyGlobalUniformBuffers(PsoInit.BoundShaderState.GeometryShaderRHI, ResourceCast(PsoInit.BoundShaderState.GeometryShaderRHI));
			ApplyGlobalUniformBuffers(PsoInit.BoundShaderState.PixelShaderRHI, ResourceCast(PsoInit.BoundShaderState.PixelShaderRHI));
		}

		// Store the PSO's primitive (after since IRHICommandContext::RHISetGraphicsPipelineState sets the BSS)
		PrimitiveType = PsoInit.PrimitiveType;
	}
```

이제 RHI 레이어를 지나 OpenGL용 코드이다.

```cpp
FBoundShaderStateRHIRef FOpenGLDynamicRHI::RHICreateBoundShaderState_OnThisThread(
	FRHIVertexDeclaration* VertexDeclarationRHI,
	FRHIVertexShader* VertexShaderRHI,
	FRHIHullShader* HullShaderRHI,
	FRHIDomainShader* DomainShaderRHI,
	FRHIPixelShader* PixelShaderRHI,
	FRHIGeometryShader* GeometryShaderRHI,
    // ⭐
    // PSO PreCompile에서 호출된 경우 1이다
	bool bFromPSOFileCache
    // ⭐
	)
{
	check(IsInRenderingThread() || IsInRHIThread());

	FScopeLock Lock(&GProgramBinaryCacheCS);

	VERIFY_GL_SCOPE();

	SCOPE_CYCLE_COUNTER(STAT_OpenGLCreateBoundShaderStateTime);

	if (!PixelShaderRHI)
	{
		// use special null pixel shader when PixelShader was set to NULL
		PixelShaderRHI = TShaderMapRef<FNULLPS>(GetGlobalShaderMap(GMaxRHIFeatureLevel)).GetPixelShader();
	}
    
	auto CreateConfig = [VertexShaderRHI, HullShaderRHI, DomainShaderRHI, PixelShaderRHI, GeometryShaderRHI]()
	{
		FOpenGLVertexShader* VertexShader = ResourceCast(VertexShaderRHI);
		FOpenGLPixelShader* PixelShader = ResourceCast(PixelShaderRHI);
		FOpenGLHullShader* HullShader = ResourceCast(HullShaderRHI);
		FOpenGLDomainShader* DomainShader = ResourceCast(DomainShaderRHI);
		FOpenGLGeometryShader* GeometryShader = ResourceCast(GeometryShaderRHI);

		FOpenGLLinkedProgramConfiguration Config;

		check(VertexShader);
		check(PixelShader);

		// Fill-in the configuration
		Config.Shaders[CrossCompiler::SHADER_STAGE_VERTEX].Bindings = VertexShader->Bindings;
		Config.Shaders[CrossCompiler::SHADER_STAGE_VERTEX].Resource = VertexShader->Resource;
		Config.ProgramKey.ShaderHashes[CrossCompiler::SHADER_STAGE_VERTEX] = VertexShaderRHI->GetHash();

		if (FOpenGL::SupportsTessellation())
		{
			if (HullShader)
			{
				check(VertexShader);
				BindShaderStage(Config, CrossCompiler::SHADER_STAGE_HULL, HullShader, HullShaderRHI->GetHash(), CrossCompiler::SHADER_STAGE_VERTEX, VertexShader);
			}
			if (DomainShader)
			{
				check(HullShader);
				BindShaderStage(Config, CrossCompiler::SHADER_STAGE_DOMAIN, DomainShader, DomainShaderRHI->GetHash(), CrossCompiler::SHADER_STAGE_HULL, HullShader);
			}
		}

		if (GeometryShader)
		{
			check(DomainShader || VertexShader);
			if (DomainShader)
			{
				BindShaderStage(Config, CrossCompiler::SHADER_STAGE_GEOMETRY, GeometryShader, GeometryShaderRHI->GetHash(), CrossCompiler::SHADER_STAGE_DOMAIN, DomainShader);
			}
			else
			{
				BindShaderStage(Config, CrossCompiler::SHADER_STAGE_GEOMETRY, GeometryShader, GeometryShaderRHI->GetHash(), CrossCompiler::SHADER_STAGE_VERTEX, VertexShader);
			}
		}

		check(DomainShader || GeometryShader || VertexShader);
		if (DomainShader)
		{
			BindShaderStage(Config, CrossCompiler::SHADER_STAGE_PIXEL, PixelShader, PixelShaderRHI->GetHash(), CrossCompiler::SHADER_STAGE_DOMAIN, DomainShader);
		}
		else if (GeometryShader)
		{
			BindShaderStage(Config, CrossCompiler::SHADER_STAGE_PIXEL, PixelShader, PixelShaderRHI->GetHash(), CrossCompiler::SHADER_STAGE_GEOMETRY, GeometryShader);
		}
		else
		{
			BindShaderStage(Config, CrossCompiler::SHADER_STAGE_PIXEL, PixelShader, PixelShaderRHI->GetHash(), CrossCompiler::SHADER_STAGE_VERTEX, VertexShader);
		}
		return Config;
	};

    // ⭐
    // 미리 캐싱해둔 BoundShaderState에서 매칭되는 BoundShaderState가 있는지 확인한다.
    //
	// Check for an existing bound shader state which matches the parameters
	FCachedBoundShaderStateLink* CachedBoundShaderStateLink = GetCachedBoundShaderState(
		VertexDeclarationRHI,
		VertexShaderRHI,
		PixelShaderRHI,
		HullShaderRHI,
		DomainShaderRHI,
		GeometryShaderRHI
		);
    // ⭐

	if(CachedBoundShaderStateLink)
	{
		// If we've already created a bound shader state with these parameters, reuse it.
		FOpenGLBoundShaderState* BoundShaderState = ResourceCast(CachedBoundShaderStateLink->BoundShaderState);
		FOpenGLLinkedProgram* LinkedProgram = BoundShaderState->LinkedProgram;
		GetOpenGLProgramsCache().Touch(LinkedProgram);

		if (!LinkedProgram->bConfigIsInitalized)
		{
			// touch has unevicted the program, set it up.
			FOpenGLLinkedProgramConfiguration Config = CreateConfig();
			LinkedProgram->SetConfig(Config);
			// We now have the config for this program, we must configure the program for use.
			ConfigureGLProgramStageStates(LinkedProgram);
		}
		return CachedBoundShaderStateLink->BoundShaderState;
	}
	else
	{
		FOpenGLLinkedProgramConfiguration Config = CreateConfig();

		// Check if we already have such a program in released programs cache. Use it, if we do.
		FOpenGLLinkedProgram* LinkedProgram = 0;

        // ⭐
        // LRU 정책을 사용하지 않거나, 사용하더라도 아직 Evict하지 않아도 되는 경우
        // 파괴할 Program 오브젝트를 파괴하지 않고 StaticLastReleasedPrograms에 LAST_RELEASED_PROGRAMS_CACHE_COUNT 개수만큼까지는 보관해둔다.
        // FOpenGLBoundShaderState::~FOpenGLBoundShaderState() 함수 참고.
		int32 Index = StaticLastReleasedProgramsIndex;
		for( int CacheIndex = 0; CacheIndex < LAST_RELEASED_PROGRAMS_CACHE_COUNT; ++CacheIndex )
		{
			FOpenGLLinkedProgram* Prog = StaticLastReleasedPrograms[Index];
			if( Prog && Prog->Config == Config )
			{
				StaticLastReleasedPrograms[Index] = 0;
				LinkedProgram = Prog;
				GetOpenGLProgramsCache().Touch(LinkedProgram);
				break;
			}
			Index = (Index == LAST_RELEASED_PROGRAMS_CACHE_COUNT-1) ? 0 : Index+1;
		}
        // ⭐

		if (!LinkedProgram)
		{
			bool bFindAndCreateEvictedProgram = true;
			// If this is this a request from the PSOFC then do not create an evicted program.
			if (bFromPSOFileCache && GetOpenGLProgramsCache().IsUsingLRU())
			{
				bFindAndCreateEvictedProgram = false;
			}

            // ⭐
            // Program 오브젝트도 캐싱해둔다.
            // Probram Binary의 개념이랑은 다르다.
            // 여기서 말하는 캐싱은 그냥 생성했던 Program 오브젝트를 사용 후 곧 바로 파괴하지 않고 쉐이더 메모리에 보관해둔다는 개념이다.
			FOpenGLLinkedProgram* CachedProgram = GetOpenGLProgramsCache().Find(Config.ProgramKey, bFindAndCreateEvictedProgram);
			if (!CachedProgram)
			{
				// ensure that pending request for this program has been completed before
				if (FOpenGLProgramBinaryCache::CheckSinglePendingGLProgramCreateRequest(Config.ProgramKey))
				{
					CachedProgram = GetOpenGLProgramsCache().Find(Config.ProgramKey, bFindAndCreateEvictedProgram);
				}
			}
            // ⭐

			if (CachedProgram)
			{
				LinkedProgram = CachedProgram;
				if (!LinkedProgram->bConfigIsInitalized && bFindAndCreateEvictedProgram)
				{
					LinkedProgram->SetConfig(Config);
					// We now have the config for this program, we must configure the program for use.
					ConfigureGLProgramStageStates(LinkedProgram);
				}
			}
            // ⭐
            // 캐싱해둔 Program 오브젝트에서 원하는 Program 오브젝트를 못 찾은 경우 Program 오브젝트를 생성한다.
			else
            // ⭐
			{
				FOpenGLVertexShader* VertexShader = ResourceCast(VertexShaderRHI);
				FOpenGLPixelShader* PixelShader = ResourceCast(PixelShaderRHI);
				FOpenGLHullShader* HullShader = ResourceCast(HullShaderRHI);
				FOpenGLDomainShader* DomainShader = ResourceCast(DomainShaderRHI);
				FOpenGLGeometryShader* GeometryShader = ResourceCast(GeometryShaderRHI);
		
				// Make sure we have OpenGL context set up, and invalidate the parameters cache and current program (as we'll link a new one soon)
				GetContextStateForCurrentContext().Program = -1;
				MarkShaderParameterCachesDirty(PendingState.ShaderParameters, false);
				PendingState.LinkedProgramAndDirtyFlag = nullptr;

                // ⭐⭐⭐⭐⭐⭐⭐
                // 위에서 말한 쉐이더들을 프로그램에 링크하는 부분이다.
                // Program Binary 캐시에 알맞은 Program Binary가 있는 경우, Program Binary에서 Program 오브젝트를 생성하고,
                // 그렇지 않은 경우에는 Program 오브젝트를 생성해서 일일이 쉐이더를 링크한다.
                //
				// Link program, using the data provided in config
				LinkedProgram = LinkProgram(Config, bFromPSOFileCache);
                // ⭐⭐⭐⭐⭐⭐⭐

				if (LinkedProgram == NULL)
				{
#if DEBUG_GL_SHADERS
					if (VertexShader)
					{
						UE_LOG(LogRHI, Error, TEXT("Vertex Shader:\n%s"), ANSI_TO_TCHAR(VertexShader->GlslCode.GetData()));
					}
					if (PixelShader)
					{
						UE_LOG(LogRHI, Error, TEXT("Pixel Shader:\n%s"), ANSI_TO_TCHAR(PixelShader->GlslCode.GetData()));
					}
					if (GeometryShader)
					{
						UE_LOG(LogRHI, Error, TEXT("Geometry Shader:\n%s"), ANSI_TO_TCHAR(GeometryShader->GlslCode.GetData()));
					}
					if (FOpenGL::SupportsTessellation())
					{
						if (HullShader)
						{
							UE_LOG(LogRHI, Error, TEXT("Hull Shader:\n%s"), ANSI_TO_TCHAR(HullShader->GlslCode.GetData()));
						}
						if (DomainShader)
						{
							UE_LOG(LogRHI, Error, TEXT("Domain Shader:\n%s"), ANSI_TO_TCHAR(DomainShader->GlslCode.GetData()));
						}
					}
#endif //DEBUG_GL_SHADERS
					FName LinkFailurePanic = bFromPSOFileCache ? FName("FailedProgramLinkDuringPrecompile") : FName("FailedProgramLink");
					RHIGetPanicDelegate().ExecuteIfBound(LinkFailurePanic);
					UE_LOG(LogRHI, Fatal, TEXT("Failed to link program [%s]. Current total programs: %d, precompile: %d"), *Config.ProgramKey.ToString(), GNumPrograms, (uint32)bFromPSOFileCache);
				}

				GetOpenGLProgramsCache().Add(Config.ProgramKey, LinkedProgram);

				// if building the cache file and using the LRU then evict the last shader created. this will reduce the risk of fragmentation of the driver's program memory.
				if (bFindAndCreateEvictedProgram == false && FOpenGLProgramBinaryCache::IsBuildingCache())
				{
					GetOpenGLProgramsCache().EvictMostRecent();
				}
			}
		}

		check(VertexDeclarationRHI);
		
		FOpenGLVertexDeclaration* VertexDeclaration = ResourceCast(VertexDeclarationRHI);

        // ⭐
        // 생성한 Program 오브젝트를 보관할 BoundShaderState를 생성한다.
        // BoundShaderState 생성과 동시에 CachedBoundShaderState에 캐싱되어 위의 GetCachedBoundShaderState에서 가져올 수 있다.
        // FOpenGLBoundShaderState는 플랫폼 Independent한 FRHIBoundShaderState를 상속한다.
		FOpenGLBoundShaderState* BoundShaderState = new FOpenGLBoundShaderState(
			LinkedProgram,
			VertexDeclarationRHI,
			VertexShaderRHI,
			PixelShaderRHI,
			GeometryShaderRHI,
			HullShaderRHI,
			DomainShaderRHI
			);
        // ⭐

		return BoundShaderState;
	}
}
```

```cpp
static FOpenGLLinkedProgram* LinkProgram( const FOpenGLLinkedProgramConfiguration& Config, bool bFromPSOFileCache)
{
	ANSICHAR Buf[32] = {0};

	SCOPE_CYCLE_COUNTER(STAT_OpenGLShaderLinkTime);
	VERIFY_GL_SCOPE();

	// ensure that compute shaders are always alone
	check( (Config.Shaders[CrossCompiler::SHADER_STAGE_VERTEX].Resource == 0) != (Config.Shaders[CrossCompiler::SHADER_STAGE_COMPUTE].Resource == 0));
	check( (Config.Shaders[CrossCompiler::SHADER_STAGE_PIXEL].Resource == 0) != (Config.Shaders[CrossCompiler::SHADER_STAGE_COMPUTE].Resource == 0));

	TArray<uint8> CachedProgramBinary;
	GLuint Program = 0;
	bool bShouldLinkProgram = true;
	if (FOpenGLProgramBinaryCache::IsEnabled())
	{
        // ⭐⭐⭐⭐⭐⭐⭐
        // ProgramKey를 해쉬 값으로 캐싱되어 있는 Program Binary 중 알맞은 Program Binary를 찾아 Program 오브젝트를 생성한다. 
        // 알맞은 Program Binary를 찾아 Program 오브젝트를 생성한 경우 밑에서 쉐이더를 링크할 필요도 없다.        
        //
		// Try to create program from a saved binary
		bShouldLinkProgram = !FOpenGLProgramBinaryCache::UseCachedProgram(Program, Config.ProgramKey, CachedProgramBinary);
        // ⭐⭐⭐⭐⭐⭐⭐

		if (bShouldLinkProgram)
		{
			// In case there is no saved binary in the cache, compile required shaders we have deferred before
			FOpenGLProgramBinaryCache::CompilePendingShaders(Config);
		}
	}

	if (Program == 0)
	{
        // ⭐
        // Program Binary가 Disable되어 있거나, 알맞은 Program Binary를 찾을 수 없어서, Program 객체가 아직 생성되지 않은 경우,
        // 드라이버에 요청해서 Program 오브젝트를 생성해준다.
		FOpenGL::GenProgramPipelines(1, &Program);
        // ⭐
	}

	if (bShouldLinkProgram)
	{
		if (Config.Shaders[CrossCompiler::SHADER_STAGE_VERTEX].Resource)
		{
			FOpenGL::UseProgramStages(Program, GL_VERTEX_SHADER_BIT, Config.Shaders[CrossCompiler::SHADER_STAGE_VERTEX].Resource);
		}
		if (Config.Shaders[CrossCompiler::SHADER_STAGE_PIXEL].Resource)
		{
			FOpenGL::UseProgramStages(Program, GL_FRAGMENT_SHADER_BIT, Config.Shaders[CrossCompiler::SHADER_STAGE_PIXEL].Resource);
		}
		if (Config.Shaders[CrossCompiler::SHADER_STAGE_GEOMETRY].Resource)
		{
			FOpenGL::UseProgramStages(Program, GL_GEOMETRY_SHADER_BIT, Config.Shaders[CrossCompiler::SHADER_STAGE_GEOMETRY].Resource);
		}
		if (Config.Shaders[CrossCompiler::SHADER_STAGE_HULL].Resource)
		{
			FOpenGL::UseProgramStages(Program, GL_TESS_CONTROL_SHADER_BIT, Config.Shaders[CrossCompiler::SHADER_STAGE_HULL].Resource);
		}
		if (Config.Shaders[CrossCompiler::SHADER_STAGE_DOMAIN].Resource)
		{
			FOpenGL::UseProgramStages(Program, GL_TESS_EVALUATION_SHADER_BIT, Config.Shaders[CrossCompiler::SHADER_STAGE_DOMAIN].Resource);
		}
		if (Config.Shaders[CrossCompiler::SHADER_STAGE_COMPUTE].Resource)
		{
			FOpenGL::UseProgramStages(Program, GL_COMPUTE_SHADER_BIT, Config.Shaders[CrossCompiler::SHADER_STAGE_COMPUTE].Resource);
		}
	
		if( !FOpenGL::SupportsSeparateShaderObjects() )
		{
			if(FOpenGLProgramBinaryCache::IsEnabled() || GetOpenGLProgramsCache().IsUsingLRU())
			{
				FOpenGL::ProgramParameter(Program, PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRUE);
			}

            // ⭐⭐⭐⭐⭐⭐⭐
			// Link.
			glLinkProgram(Program);
            // ⭐⭐⭐⭐⭐⭐⭐
		}
	}

	if (VerifyProgramPipeline(Program))
	{
		if(bShouldLinkProgram && !FOpenGL::SupportsSeparateShaderObjects())
		{
			SetNewProgramStats(Program);

			if (FOpenGLProgramBinaryCache::IsEnabled())
			{
				check(CachedProgramBinary.Num() == 0);

                // ⭐
                // Seperate Shader Object를 지원하지 않는 경우, 알맞은 Program Binary가 없어서 새롭게 Program 오브젝트를 생성하고 링크한 경우,
                // 링크된 Program 오브젝트의 Binary를 캐싱한다. ( 디스크에 쓴다 )
				FOpenGLProgramBinaryCache::CacheProgram(Program, Config.ProgramKey, CachedProgramBinary);
                // ⭐
			}
		}
	}
	else
	{
		return nullptr;
	}
	
    // ⭐
    // 생성한 Program 오브젝트를 바인딩한다.
	FOpenGL::BindProgramPipeline(Program);
    // ⭐

	bool bUsingTessellation = Config.Shaders[CrossCompiler::SHADER_STAGE_HULL].Resource && Config.Shaders[CrossCompiler::SHADER_STAGE_DOMAIN].Resource;
	FOpenGLLinkedProgram* LinkedProgram = new FOpenGLLinkedProgram(Config, Program, bUsingTessellation);

	if (GetOpenGLProgramsCache().IsUsingLRU() && CVarLRUKeepProgramBinaryResident.GetValueOnAnyThread() && CachedProgramBinary.Num())
	{
		// Store the binary data in LRUInfo, this avoids requesting a program binary from the driver when this program is evicted.
		INC_MEMORY_STAT_BY(STAT_OpenGLShaderLRUProgramMemory, CachedProgramBinary.Num());

        // ⭐
        // CVarLRUKeepProgramBinaryResident
        // : Program 바이너리를 버리지 말고 메모리에 보관해둘지. 이 경우 메모리 사용량은 증가하나, Program 오브젝트를 다시 생성할 때 빠르게 생성할 수 있다. ( 디스크에서 읽어 오지 않고.. )
		LinkedProgram->LRUInfo.CachedProgramBinary = MoveTemp(CachedProgramBinary);
        // ⭐
	}
	ConfigureStageStates(LinkedProgram);

#if ENABLE_UNIFORM_BUFFER_LAYOUT_VERIFICATION
	VerifyUniformBufferLayouts(Program);
#endif // #if ENABLE_UNIFORM_BUFFER_LAYOUT_VERIFICATION
	return LinkedProgram;
}
```

Program Binary를 캐싱하는 부분도 살펴보자.          

```cpp
void FOpenGLProgramBinaryCache::CacheProgram(GLuint Program, const FOpenGLProgramKey& ProgramKey, TArray<uint8>& CachedProgramBinaryOUT)
{
	if (CachePtr)
	{
		CachePtr->AppendGLProgramToBinaryCache(ProgramKey, Program, CachedProgramBinaryOUT);
	}
}

// Called when a new program has been created by OGL RHI, creates the binary cache if it's invalid and then appends the new program details to the file and runtime containers.
void FOpenGLProgramBinaryCache::AppendGLProgramToBinaryCache(const FOpenGLProgramKey& ProgramKey, GLuint Program, TArray<uint8>& CachedProgramBinaryOUT)
{
	if (IsBuildingCache_internal() == false)
	{
		return;
	}

	FScopeLock Lock(&GProgramBinaryCacheCS);

	AddUniqueGLProgramToBinaryCache(BinaryCacheWriteFileHandle, ProgramKey, Program, CachedProgramBinaryOUT);
}

// Add the program to the binary cache if it does not already exist.
void FOpenGLProgramBinaryCache::AddUniqueGLProgramToBinaryCache(FArchive* FileWriter, const FOpenGLProgramKey& ProgramKey, GLuint Program, TArray<uint8>& CachedProgramBinaryOUT)
{
	// Add to runtime and disk.
	const FOpenGLProgramKey& ProgramHash = ProgramKey;

	// Check we dont already have this: Something could be in the cache but still reach this point if OnSharedShaderCodeRequest(s) have not occurred.
	if (!ProgramToBinaryMap.Contains(ProgramHash))
	{
		uint32 ProgramBinaryOffset = 0, ProgramBinarySize = 0;

		FOpenGLProgramKey SerializedProgramKey = ProgramKey;

        // ⭐
        // Program 오브젝트로부터 Binary 데이터를 추출하여 CachedProgramBinaryOUT에 저장한다.
		if (ensure(GetProgramBinaryFromGLProgram(Program, CachedProgramBinaryOUT)))
        // ⭐
		{
			AddProgramBinaryDataToBinaryCache(*FileWriter, CachedProgramBinaryOUT, ProgramKey);
		}
		else
		{
			// we've encountered a problem with this program and there's nothing to write.
			// This likely means the device will never be able to use this program.
			// Panic!
			RHIGetPanicDelegate().ExecuteIfBound(FName("FailedBinaryProgramWrite"));
			UE_LOG(LogRHI, Fatal, TEXT("AppendProgramBinaryFile Binary program returned 0 bytes!"));
			// Panic!
		}
	}
}

// Serialize out the program binary data and add to runtime structures.
void FOpenGLProgramBinaryCache::AddProgramBinaryDataToBinaryCache(FArchive& Ar, TArray<uint8>& BinaryProgramData, const FOpenGLProgramKey& ProgramKey)
{
    // ⭐
    // Program Binary를 디스크에 써서 보관해둔다.
	// Serialize to output file:
	FOpenGLProgramKey SerializedProgramKey = ProgramKey;
	uint32 ProgramBinarySize = (uint32)BinaryProgramData.Num();
	Ar << SerializedProgramKey;
	uint32 ProgramBinaryOffset = Ar.Tell();
	Ar << ProgramBinarySize;
	Ar.Serialize(BinaryProgramData.GetData(), ProgramBinarySize);
    // ⭐

    // ⭐
    // Program Binary를 압축하여 디스크에 써둘 수도 있다.         
	if(CVarStoreCompressedBinaries.GetValueOnAnyThread())
	{
		static uint32 TotalUncompressed = 0;
		static uint32 TotalCompressed = 0;

		FCompressedProgramBinaryHeader* Header = (FCompressedProgramBinaryHeader*)BinaryProgramData.GetData();
		TotalUncompressed += Header->UncompressedSize;
		TotalCompressed += BinaryProgramData.Num();

		UE_LOG(LogRHI, Verbose, TEXT("AppendProgramBinaryFile: total Uncompressed: %d, total Compressed %d, Total saved so far: %d"), TotalUncompressed, TotalCompressed, TotalUncompressed - TotalCompressed);
	}
    // ⭐

	FGLProgramBinaryFileCacheEntry* NewIndexEntry = new FGLProgramBinaryFileCacheEntry();
	ProgramEntryContainer.Emplace(TUniquePtr<FGLProgramBinaryFileCacheEntry>(NewIndexEntry));

	// Store the program file descriptor in the runtime program/shader container:
	NewIndexEntry->GLProgramState = FGLProgramBinaryFileCacheEntry::EGLProgramState::ProgramStored;
	NewIndexEntry->FileInfo.ProgramOffset = ProgramBinaryOffset;
	NewIndexEntry->FileInfo.ProgramSize = ProgramBinarySize;
	NewIndexEntry->ProgramIndex = ProgramToBinaryMap.Num();
	NewIndexEntry->FileInfo.ShaderHasheSet = ProgramKey;
	AddProgramFileEntryToMap(NewIndexEntry);
}
```

Program Binary로부터 Program 오브젝트를 생성하는 부분도 보자.

```cpp
bool FOpenGLProgramBinaryCache::UseCachedProgram(GLuint& ProgramOUT, const FOpenGLProgramKey& ProgramKey, TArray<uint8>& CachedProgramBinaryOUT)
{
	if (CachePtr)
	{
		return CachePtr->UseCachedProgram_internal(ProgramOUT, ProgramKey, CachedProgramBinaryOUT);
	}
	return false;
}

bool FOpenGLProgramBinaryCache::UseCachedProgram_internal(GLuint& ProgramOUT, const FOpenGLProgramKey& ProgramKey, TArray<uint8>& CachedProgramBinaryOUT)
{
	SCOPE_CYCLE_COUNTER(STAT_OpenGLUseCachedProgramTime);
	
	FGLProgramBinaryFileCacheEntry** ProgramBinRefPtr = nullptr;

	FScopeLock Lock(&GProgramBinaryCacheCS);

	ProgramBinRefPtr = ProgramToBinaryMap.Find(ProgramKey);

    // ⭐
    // 이전에 디스크의 Program Binary를 로드하여 Program 오브젝트까지 생성해둔 경우.
	if (ProgramBinRefPtr)
    // ⭐
	{
		FGLProgramBinaryFileCacheEntry* FoundProgram = *ProgramBinRefPtr;
		check(FoundProgram->FileInfo.ShaderHasheSet == ProgramKey);

		TSharedPtr<IAsyncReadRequest, ESPMode::ThreadSafe> LocalReadRequest = FoundProgram->ReadRequest.Pin();
		bool bHasReadRequest = LocalReadRequest.IsValid();
		check(!bHasReadRequest);

		// by this point the program must be either available or no attempt to load from shader library has occurred.
		checkf(FoundProgram->GLProgramState == FGLProgramBinaryFileCacheEntry::EGLProgramState::ProgramStored
			|| FoundProgram->GLProgramState == FGLProgramBinaryFileCacheEntry::EGLProgramState::ProgramAvailable,
			TEXT("Unexpected program state:  (%s) == %d"), *ProgramKey.ToString(), (int32)FoundProgram->GLProgramState);

		if (FoundProgram->GLProgramState == FGLProgramBinaryFileCacheEntry::EGLProgramState::ProgramAvailable)
		{
			UE_LOG(LogRHI, Log, TEXT("UseCachedProgram : Program (%s) GLid = %x is ready!"), *ProgramKey.ToString(), FoundProgram->GLProgramId);

            // ⭐
            // Program Binary로부터 미리 생성해둔 Program 오브젝트를 반환다.
			ProgramOUT = FoundProgram->GLProgramId;
            // ⭐

			// GLProgram has been handed over.
			FoundProgram->GLProgramId = 0;
			FoundProgram->GLProgramState = FGLProgramBinaryFileCacheEntry::EGLProgramState::ProgramComplete;
			return true;
		}
		else
		{
			UE_LOG(LogRHI, Log, TEXT("UseCachedProgram : %s was not ready when needed!! (state %d)"), *ProgramKey.ToString(), (uint32)FoundProgram->GLProgramState);
		}
	}
    // ⭐
    // 디스크의 Program Binary를 미리 메모리에 로드해두지 않은 경우
	else if (BinaryFileState == EBinaryFileState::BuildingCacheFileWithMove)
    // ⭐
	{
		// We're building the new cache using the original cache to warm:
		TUniquePtr<FGLProgramBinaryFileCacheEntry>* FoundExistingBinary = PreviousBinaryCacheInfo.ProgramToOldBinaryCacheMap.Find(ProgramKey);
		if (FoundExistingBinary)
		{
            // ⭐
            // 디스크로부터 Program Binary를 읽어 Program 오브젝트를 생성한다. 
            //
			TUniquePtr<FGLProgramBinaryFileCacheEntry>& ExistingBinary = *FoundExistingBinary;
			// read old binary:
			CachedProgramBinaryOUT.SetNumUninitialized(ExistingBinary->FileInfo.ProgramSize);
			PreviousBinaryCacheInfo.OldCacheArchive->Seek(ExistingBinary->FileInfo.ProgramOffset);
			PreviousBinaryCacheInfo.OldCacheArchive->Serialize(CachedProgramBinaryOUT.GetData(), ExistingBinary->FileInfo.ProgramSize);
			bool bSuccess = CreateGLProgramFromBinary(ProgramOUT, CachedProgramBinaryOUT);
            // ⭐

			if (!bSuccess)
			{
				UE_LOG(LogRHI, Log, TEXT("[%s, %d, %d]"), *ProgramKey.ToString(), ProgramOUT, CachedProgramBinaryOUT.Num());
				RHIGetPanicDelegate().ExecuteIfBound(FName("FailedBinaryProgramCreateFromOldCache"));
				UE_LOG(LogRHI, Fatal, TEXT("UseCachedProgram : Failed to create GL program from binary data while BuildingCacheFileWithMove! [%s]"), *ProgramKey.ToString());
			}
			SetNewProgramStats(ProgramOUT);

            // ⭐
            // 디스크로부터 읽어온 Program Binary는 이후 캐싱을 위해 다시 파일에 쓴다.
			// Now write to new cache, we're returning true here so no attempt will be made to add it back to the cache later.
			AddProgramBinaryDataToBinaryCache(*BinaryCacheWriteFileHandle, CachedProgramBinaryOUT, ProgramKey);
            // ⭐

			PreviousBinaryCacheInfo.NumberOfOldEntriesReused++;
			return true;
		}
	}
	return false;
}
```

위에서 OpenGL는 바운딩된 쉐이더 스테이트(BSS)에 대한 캐싱만을 지원한다고 했는데 이는 코드에서도 확인할 수 있다.

```cpp
void FPipelineFileCache::CacheGraphicsPSO(uint32 RunTimeHash, FGraphicsPipelineStateInitializer const& Initializer)
{
	if(IsPipelineFileCacheEnabled() && (LogPSOtoFileCache() || ReportNewPSOs()))
	{
		FRWScopeLock Lock(FileCacheLock, SLT_ReadOnly);
	
		if(FileCache)
		{
			FPSOUsageData* PSOUsage = RunTimeToPSOUsage.Find(RunTimeHash);
			if(PSOUsage == nullptr || !IsReferenceMaskSet(FPipelineFileCache::GameUsageMask, PSOUsage->UsageMask))
			{
				Lock.ReleaseReadOnlyLockAndAcquireWriteLock_USE_WITH_CAUTION();
				PSOUsage = RunTimeToPSOUsage.Find(RunTimeHash);
				
				if(PSOUsage == nullptr)
				{
					FPipelineCacheFileFormatPSO NewEntry;
					bool bOK = FPipelineCacheFileFormatPSO::Init(NewEntry, Initializer);
					check(bOK);
					
					uint32 PSOHash = GetTypeHash(NewEntry);
					FPSOUsageData CurrentUsageData(PSOHash, 0, 0);
					
					if (!FileCache->IsPSOEntryCached(NewEntry, &CurrentUsageData))
					{
						bool bActuallyNewPSO = !NewPSOHashes.Contains(PSOHash);
						
						// ⭐
						// OpenGL은 BSS가 동일한지만을 가지고 전달된 PSO가 새로운 PSO인지를 확인한다.
						if (bActuallyNewPSO && IsOpenGLPlatform(GMaxRHIShaderPlatform)) // OpenGL is a BSS platform and so we don't report BSS matches as missing.
						{
							bActuallyNewPSO = !FileCache->IsBSSEquivalentPSOEntryCached(NewEntry);
						}
						// ⭐

						if (bActuallyNewPSO)
						{
							CSV_EVENT(PSO, TEXT("Encountered new graphics PSO"));
							UE_LOG(LogRHI, Display, TEXT("Encountered a new graphics PSO: %u"), PSOHash);
							if (GPSOFileCachePrintNewPSODescriptors > 0)
							{
								UE_LOG(LogRHI, Display, TEXT("New Graphics PSO (%u) Description: %s"), PSOHash, *NewEntry.GraphicsDesc.ToString());
							}
							if (LogPSOtoFileCache())
							{
								NewPSOs.Add(NewEntry);
								INC_MEMORY_STAT_BY(STAT_NewCachedPSOMemory, sizeof(FPipelineCacheFileFormatPSO) + sizeof(uint32) + sizeof(uint32));
							}
							NewPSOHashes.Add(PSOHash);

							NumNewPSOs++;
							INC_DWORD_STAT(STAT_NewGraphicsPipelineStateCount);
							INC_DWORD_STAT(STAT_TotalGraphicsPipelineStateCount);
							
							if (ReportNewPSOs() && PSOLoggedEvent.IsBound())
							{
								PSOLoggedEvent.Broadcast(NewEntry);
							}
						}
					}
					
					// Only set if the file cache doesn't have this Mask for the PSO - avoid making more entries and unnessary file saves
					if(!IsReferenceMaskSet(FPipelineFileCache::GameUsageMask, CurrentUsageData.UsageMask))
					{
						CurrentUsageData.UsageMask |= FPipelineFileCache::GameUsageMask;
						RegisterPSOUsageDataUpdateForNextSave(CurrentUsageData);
					}
					
					// Apply the existing file PSO Usage mask and current to our "fast" runtime check
					RunTimeToPSOUsage.Add(RunTimeHash, CurrentUsageData);
				}
				else if(!IsReferenceMaskSet(FPipelineFileCache::GameUsageMask, PSOUsage->UsageMask))
				{
					PSOUsage->UsageMask |= FPipelineFileCache::GameUsageMask;
					RegisterPSOUsageDataUpdateForNextSave(*PSOUsage);
				}
			}
		}
	}
}
```